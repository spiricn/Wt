#ifndef WT_ASCENEACTOR_H
#define WT_ASCENEACTOR_H


#include "wt/stdafx.h"


#include "wt/Transform.h"
#include "wt/Model.h"
#include "wt/ASerializable.h"
#include "wt/SkeletalAnimationPlayer.h"

namespace wt{

class PhysicsActor;
class Scene;

class ASceneActor{
public:
	enum ActorType{
		eTYPE_TERRAIN,
		eTYPE_EFFECT,
		eTYPE_MODELLED
	};

protected:
	/** Owner of the actor (scene which created it) */
	Scene* mParent;

	/** Name of the actor, might not be set and is not a unique identifier */
	String mName;
	
	/** Unique actor identification generated by the Scene */
	uint32_t mId;

	/** Indicates wheter or not he user data has been set by the user */
	bool mUserDataSet;

	/** Data set by the user */
	void* mUserData;

	/** Type of the actor, used for RTTI */
	ActorType mType;

	math::Transform mTransform;

	/** Scene actor may be paired with a physics actor for its physicall representation */
	PhysicsActor* mPhysicsActor;

public:
	ASceneActor(Scene* parent, ActorType type, uint32_t id, const String& name="") : mName(name), mId(id),
		mUserData(NULL), mUserDataSet(false), mParent(parent), mPhysicsActor(NULL){
	}

	ActorType getActorType() const{
		return mType;
	}

	void* getUserData() const{
		return mUserData;
	}

	void setUserData(void* data){
		mUserDataSet = true;
		mUserData = data;
	}

	PhysicsActor* getPhysicsActor(){
		return mPhysicsActor;
	}

	void setPhysicsActor(PhysicsActor* actor){
		mPhysicsActor = actor;
	}
	bool hasUserData() const{
		return mUserDataSet;
	}

	virtual ~ASceneActor(){
	}

	uint32_t getId() const{
		return mId;
	}	

	const String& getName() const{
		return mName;
	}

	math::Transform& getTransform(){
		return mTransform;
	}

	const math::Transform& getTransform() const{
		return mTransform;
	}

	virtual void update(float /*dt*/){
	}

}; // </ASceneActor>


}; // </wt>

#endif // </WT_ASCENEACTOR_H>