/*********************************************
 * AUTO-GENERATED FILE.  DO NOT MODIFY. 
 *
 * 2014-02-23 14:08:51.165953
 *
 * This file was automatically generated by the 'shader_compiler.py' script
 * It should not be modified by hand.
 *********************************************/


#include "wt/stdafx.h"
#include "wt/CompiledShaders.h"
#include <map>

#define TD_TRACE_TAG "CompiledShaders"

namespace wt
{

typedef std::map<std::string, const char*> SourceMap;

static SourceMap gSourceMap;
static bool gMapInitialized = false;

/* Generated from "./shaders\font.vp" */
static const char* font_vp = 
	"#version 130\n"
	"\n"
	"in vec4 aVertex;\n"
	"\n"
	"out vec2 fsTexCoord;\n"
	"\n"
	"uniform mat4x4 uMatProj;\n"
	"uniform mat4x4 uModelViewMat;\n"
	"\n"
	"void main(){\n"
	"	gl_Position = (uModelViewMat * uMatProj) * vec4(aVertex.xy, 0, 1); // 2 dimensional coordinates\n"
	"\n"
	"	fsTexCoord = vec2(aVertex[2], aVertex[3]); // other two components of aVertex are used as tex coords\n"
	"}\n"
; // </font_vp>

/* Generated from "./shaders\godray.vp" */
static const char* godray_vp = 
	"#version 330\n"
	"\n"
	"in vec4 inPosition;\n"
	"in vec2 inTexCoord;\n"
	"\n"
	"out vec2 fsTexCoord;\n"
	"\n"
	"uniform mat4 uMVPMat;\n"
	"\n"
	"void main(){\n"
	"\n"
	"	fsTexCoord = inTexCoord;\n"
	"\n"
	"	gl_Position = uMVPMat*inPosition;\n"
	"}\n"
; // </godray_vp>

/* Generated from "./shaders\godraysun.vp" */
static const char* godraysun_vp = 
	"#version 130\n"
	"\n"
	"in vec4 inPosition;\n"
	"\n"
	"uniform mat4 uModelMat;\n"
	"uniform mat4 uViewMat;\n"
	"uniform mat4 uProjMat;\n"
	"uniform float uSunSize;\n"
	"\n"
	"void main(){\n"
	"	gl_PointSize = uSunSize;\n"
	"\n"
	"	gl_Position = (uProjMat * (uViewMat*uModelMat)) * inPosition;\n"
	"}\n"
	"\n"
; // </godraysun_vp>

/* Generated from "./shaders\light_pass.vp" */
static const char* light_pass_vp = 
	"#version 130\n"
	"\n"
	"in vec3 inPosition;\n"
	"\n"
	"uniform mat4 uModelMat;\n"
	"uniform mat4 uViewMat;\n"
	"uniform mat4 uProjMat;\n"
	"uniform mat4 uLightViewMat;\n"
	"\n"
	"out mat4 fsLightProjMat;\n"
	"\n"
	"void main(){\n"
	"\n"
	"	fsLightProjMat = uProjMat;\n"
	"\n"
	"	gl_Position = (uProjMat*(uViewMat*uModelMat)) * vec4(inPosition, 1.0);\n"
	"}\n"
; // </light_pass_vp>

/* Generated from "./shaders\model.vp" */
static const char* model_vp = 
	"#version 330\n"
	"\n"
	"#define DISABLE(x) (x*0.00000000000000000000000000000001)\n"
	"\n"
	"#define eNORMAL_PASS 0\n"
	"#define eGODRAY_PASS 1\n"
	"#define eSHADOW_PASS 2\n"
	"\n"
	"in vec4 inVertex;\n"
	"in vec2 inTexCoord;\n"
	"in vec3 inNormals;\n"
	"in vec4 inBoneIds;\n"
	"in vec4 inWeights;\n"
	"in vec3 inTangent;\n"
	"\n"
	"out vec2 fsTexCoords;\n"
	"out vec3 fsNormal;\n"
	"out vec3 fsWorldPos;\n"
	"out vec3 fsEyePos;\n"
	"out vec3 fsTangent;\n"
	"\n"
	"const int MAX_BONES = 200;\n"
	"\n"
	"uniform mat4x4 uModelMat;\n"
	"uniform mat4x4 uProjMat;\n"
	"uniform mat4x4 uViewMat;\n"
	"uniform mat4x4 uBones[MAX_BONES];\n"
	"uniform int uPassType;\n"
	"\n"
	"//#define SKIN_DISABLE\n"
	"\n"
	"void main(void) {\n"
	"	\n"
	"	mat4x4 modelViewMat = uViewMat * uModelMat;\n"
	"	mat4x4 modelViewProjMat = uProjMat * modelViewMat;\n"
	"\n"
	"	if(uPassType == eNORMAL_PASS){\n"
	"		// vertex normal\n"
	"		fsNormal = (uModelMat * vec4(inNormals, 0.0)).xyz;\n"
	"	}\n"
	"\n"
	"	// vertex position\n"
	"	vec4 pos = inVertex;\n"
	"\n"
	"	// is the vertex bound to some bones?\n"
	"#ifdef SKIN_DISABLE\n"
	"	if(int(inBoneIds[0]) == 13099){\n"
	"#else\n"
	"	if(int(inBoneIds[0]) != MAX_BONES){\n"
	"#endif\n"
	"\n"
	"		mat4x4 boneTransform = mat4(0.0f);\n"
	"\n"
	"		// generate bone transformation matrix\n"
	"		for(int i=0; i<4; i++){\n"
	"			int boneIndex = int( inBoneIds[i] );\n"
	"\n"
	"			if(boneIndex == MAX_BONES){\n"
	"				// no more bones\n"
	"				break;\n"
	"			}\n"
	"			else{\n"
	"				boneTransform += ( uBones[ boneIndex ] * inWeights[i] );\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// animate vertex\n"
	"		pos = boneTransform*pos;\n"
	"\n"
	"		if(uPassType == eNORMAL_PASS){\n"
	"			fsNormal = (boneTransform*vec4(fsNormal, 0.0)).xyz;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if(uPassType == eNORMAL_PASS){\n"
	"		fsTexCoords = inTexCoord.st;\n"
	"		fsTangent = (uModelMat * vec4(inTangent.xyz, 1.0)).xyz;\n"
	"		fsWorldPos = (uModelMat * vec4(pos.xyz, 1.0)).xyz;\n"
	"	}\n"
	"\n"
	"	// final vertex position output\n"
	"    gl_Position = modelViewProjMat * pos;\n"
	"}\n"
; // </model_vp>

/* Generated from "./shaders\model_deferred.vp" */
static const char* model_deferred_vp = 
	"#version 330\n"
	"\n"
	"in vec4 inVertex;\n"
	"in vec2 inTexCoord;\n"
	"in vec3 inNormals;\n"
	"in vec4 inBoneIds;\n"
	"in vec4 inWeights;\n"
	"in vec3 inTangent;\n"
	"\n"
	"out vec3 fsWorldPos;\n"
	"out vec3 fsNormal;\n"
	"out vec2 fsTexCoord;\n"
	"out vec3 fsTangent;\n"
	"\n"
	"const int MAX_BONES = 200;\n"
	"\n"
	"uniform mat4x4 uModelMat;\n"
	"uniform mat4x4 uProjMat;\n"
	"uniform mat4x4 uViewMat;\n"
	"uniform mat4x4 uBones[MAX_BONES];\n"
	"\n"
	"uniform int uPassType;\n"
	"\n"
	"//#define SKIN_DISABLE\n"
	"\n"
	"void main(){\n"
	"	// Transform matrices\n"
	"	mat4x4 modelViewMat = uViewMat * uModelMat;\n"
	"	mat4x4 modelViewProjMat = uProjMat * modelViewMat;\n"
	"\n"
	"	// Vertex position\n"
	"	vec4 pos = inVertex;\n"
	"\n"
	"	// Vertex normal\n"
	"	vec4 normal = vec4(inNormals, 0.0);\n"
	"\n"
	"	// Ss the vertex bound to some bones?\n"
	"	if(int(inBoneIds[0]) != MAX_BONES){\n"
	"\n"
	"		mat4x4 boneTransform = mat4(0.0f);\n"
	"\n"
	"		// generate bone transformation matrix\n"
	"		for(int i=0; i<4; i++){\n"
	"			int boneIndex = int( inBoneIds[i] );\n"
	"\n"
	"			if(boneIndex == MAX_BONES){\n"
	"				// no more bones\n"
	"				break;\n"
	"			}\n"
	"			else{\n"
	"				boneTransform += ( uBones[ boneIndex ] * inWeights[i] );\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// Animate position\n"
	"		pos = boneTransform*pos;\n"
	"\n"
	"		// Animate normal\n"
	"		normal = boneTransform*normal;\n"
	"	}\n"
	"\n"
	"	fsTexCoord = inTexCoord.st;\n"
	"	\n"
	"	fsWorldPos = (uModelMat * pos).xyz;\n"
	"\n"
	"	fsNormal = (uModelMat * normal).xyz;\n"
	"\n"
	"	// Pass through tangent\n"
	"	fsTangent = inTangent;\n"
	"\n"
	"#if 0\n"
	"	gl_Position = (uProjMat * uViewMat) * vec4(fsWorldPos, 1.0f);\n"
	"#else\n"
	"	gl_Position = modelViewProjMat * pos;\n"
	"#endif`\n"
	"}\n"
; // </model_deferred_vp>

/* Generated from "./shaders\particle.vp" */
static const char* particle_vp = 
	"#version 130\n"
	"\n"
	"#pragma include noise3D.glsl\n"
	"\n"
	"in float inType;\n"
	"in vec3 inPosition;\n"
	"in float inLife;\n"
	"in vec3 inVelocity;\n"
	"in float inSize;\n"
	"in float inMaxLife;\n"
	"\n"
	"// Geometry shader outputs\n"
	"out float gType;\n"
	"out vec3 gPosition;\n"
	"out float gLife;\n"
	"out vec3 gVelocity;\n"
	"out float gSize;\n"
	"out float gMaxLife;\n"
	"\n"
	"void main(){\n"
	"	// Just pass everything to the geometry shader\n"
	"	gType = inType;\n"
	"	gPosition = inPosition;\n"
	"	gLife = inLife;\n"
	"	gVelocity = inVelocity;\n"
	"	gSize = inSize;\n"
	"	gMaxLife = inMaxLife;\n"
	"}\n"
; // </particle_vp>

/* Generated from "./shaders\particle_gp.vp" */
static const char* particle_gp_vp = 
	"#version 330\n"
	"\n"
	"layout(points) in;\n"
	"layout(points) out;\n"
	"layout(max_vertices=2) out;\n"
	"\n"
	"// Input from the vertex shader\n"
	"in float gType[];\n"
	"in vec3 gPosition[];\n"
	"in float gLife[];\n"
	"in vec3 gVelocity[];\n"
	"in float gSize[];\n"
	"in float gMaxLife[];\n"
	"\n"
	"// Transform feedback output\n"
	"out float outType;\n"
	"out vec3 outPosition;\n"
	"out float outLife;\n"
	"out vec3 outVelocity;\n"
	"out float outSize;\n"
	"out float outMaxLife;\n"
	"\n"
	"// Time delta since the last update\n"
	"uniform float uDt;\n"
	"\n"
	"// Random number seed\n"
	"uniform int uSeed;\n"
	"\n"
	"// Life\n"
	"uniform float uMaxLife;\n"
	"uniform float uMinLife;\n"
	"\n"
	"// Size\n"
	"uniform float uMaxSize;\n"
	"uniform float uMinSize;\n"
	"\n"
	"// Velocity\n"
	"uniform vec3 uLocalVelocity;\n"
	"uniform vec3 uRandomVelocity;\n"
	"\n"
	"uniform float uEmissionRate;\n"
	"uniform vec3 uEmissionVolume;\n"
	"\n"
	"uniform sampler2D uRandomTexture;\n"
	"\n"
	"uniform mat4 uModelMat;\n"
	"\n"
	"uniform int uWorldSpaceSim;\n"
	"\n"
	"uniform int uAlive;\n"
	"\n"
	"int seed;\n"
	"\n"
	"#define TYPE_EMITTER 1.0f\n"
	"\n"
	"#define TYPE_PARTICLE 0.0f\n"
	"\n"
	"float seedx, seedy;\n"
	"\n"
	"vec3 randomSample(){\n"
	"	vec3 sample = texture(uRandomTexture, vec2(seedx, seedy)).xyz;\n"
	"\n"
	"	seedx = sample.x * sample.y * 2;\n"
	"	seedy = sample.y * sample.z * 2;\n"
	"\n"
	"	return sample;\n"
	"}\n"
	"\n"
	"\n"
	"void main(){\n"
	"	seedx = uSeed * (gLife[0] + 1);\n"
	"	seedy = uSeed * (gLife[0] + 2);\n"
	"\n"
	"	float life = gLife[0];\n"
	"\n"
	"	life = life - uDt ;\n"
	"	\n"
	"\n"
	"	// Is the particle emitter? \n"
	"	if(gType[0] == TYPE_EMITTER){\n"
	"		// Update emitter\n"
	"		outType = TYPE_EMITTER;\n"
	"		if(life <= 0.0){\n"
	"			outLife = 1.0 / uEmissionRate;\n"
	"		}\n"
	"		else{\n"
	"			outLife = life;\n"
	"		}\n"
	"\n"
	"		EmitVertex();\n"
	"		EndPrimitive();\n"
	"\n"
	"		// TODO depending on the time passed (dt) we might\n"
	"		// need to emit more than one particle (e.g. if dt == 1 and emission rate is 4 we need to emit 4 particles, not one)\n"
	"\n"
	"		// Emit a new particle if the emiter died\n"
	"		if(life <= 0.0 && uAlive == 1){\n"
	"			// Get 3 random numbers for misc usage\n"
	"			vec3 r = randomSample();\n"
	"\n"
	"			outType = TYPE_PARTICLE;\n"
	"\n"
	"			// Calculate starting position\n"
	"			vec3 positionOffset = ( -uEmissionVolume + 2*randomSample()*uEmissionVolume );\n"
	"\n"
	"			if(uWorldSpaceSim == 1){\n"
	"				outPosition = (uModelMat * vec4(positionOffset, 1.0)).xyz;\n"
	"			}\n"
	"			else{\n"
	"				outPosition = positionOffset;\n"
	"			}\n"
	"\n"
	"			// Randomize life (between min and max)\n"
	"			outLife = uMinLife + (uMaxLife-uMinLife)*r.x;\n"
	"			outMaxLife = outLife;\n"
	"\n"
	"			// Randomize velocity\n"
	"			vec3 velOffset = (-uRandomVelocity + 2*randomSample()*uRandomVelocity);\n"
	"\n"
	"			if(uWorldSpaceSim == 1){\n"
	"				mat4 rotationMat = uModelMat;\n"
	"				rotationMat[3][0] = 0;\n"
	"				rotationMat[3][1] = 0;\n"
	"				rotationMat[3][2] = 0;\n"
	"\n"
	"				outVelocity = (rotationMat*vec4(uLocalVelocity + velOffset, 1.0)).xyz;\n"
	"			}\n"
	"			else{\n"
	"				outVelocity = uLocalVelocity + velOffset;\n"
	"			}\n"
	"			\n"
	"			\n"
	"			// Randomize size\n"
	"			outSize = uMinSize + (uMaxSize-uMinSize)*r.y;\n"
	"\n"
	"			EmitVertex();\n"
	"			EndPrimitive();\n"
	"		}\n"
	"\n"
	"	}\n"
	"	// Update the particle if its not dead\n"
	"	else if(life > 0){\n"
	"		outPosition.xyz = gPosition[0] + gVelocity[0] * uDt;\n"
	"\n"
	"		outLife = life;\n"
	"		outVelocity = gVelocity[0];\n"
	"		outType = gType[0];\n"
	"		outSize = gSize[0];\n"
	"		outMaxLife = gMaxLife[0];		\n"
	"\n"
	"		EmitVertex();\n"
	"		EndPrimitive();\n"
	"	}\n"
	"}\n"
; // </particle_gp_vp>

/* Generated from "./shaders\particle_render.vp" */
static const char* particle_render_vp = 
	"#version 130\n"
	"\n"
	"#pragma include noise3D.glsl\n"
	"\n"
	"// Inputs\n"
	"in float inType;\n"
	"in vec3 inPosition;\n"
	"in float inLife;\n"
	"in vec3 inVelocity;\n"
	"in float inSize;\n"
	"in float inMaxLife;\n"
	"\n"
	"// Fragment shader output\n"
	"out vec4 fsColor;\n"
	"\n"
	"// Uniforms\n"
	"uniform vec3 uCamPos;\n"
	"uniform mat4 uModelMat;\n"
	"uniform mat4 uModelViewMat;\n"
	"uniform mat4 uProjMat;\n"
	"uniform float uSizeGrow;\n"
	"uniform int uWorldSpaceSim;\n"
	"\n"
	"// TODO get this as a uniform ?\n"
	"#define MAX_COLOR_ANIMATION 4\n"
	"\n"
	"uniform vec4 uColorAnimation[MAX_COLOR_ANIMATION];\n"
	"\n"
	"void main(){\n"
	"	// Particle life factor (ranges from 0 to 1 as the particle grows older)\n"
	"	float a = (inMaxLife-inLife) / (inMaxLife );\n"
	"\n"
	"	vec3 worldPos;\n"
	"\n"
	"	if(uWorldSpaceSim == 1){\n"
	"		worldPos = inPosition;\n"
	"	}\n"
	"	else{\n"
	"		worldPos = (uModelMat*vec4(inPosition, 1.0)).xyz;\n"
	"	}\n"
	"	\n"
	"	// Animate particle size\n"
	"	// TODO do the projection dynamically\n"
	"	gl_PointSize = ( inSize  + a*uSizeGrow*inSize) * ( 1280/length(uCamPos.xyz-worldPos) );\n"
	"\n"
	"	// Animate particle color\n"
	"\n"
	"	// Time delta between each color of the animation\n"
	"	float dt = 1.0 / ( MAX_COLOR_ANIMATION - 1);\n"
	"\n"
	"	// Since the delta is fixed, starting color index can be calculated\n"
	"	int keyIdx = int(floor(a/dt));\n"
	"\n"
	"	// Interpolate between the current and the next color\n"
	"	fsColor = mix(uColorAnimation[keyIdx], uColorAnimation[ (keyIdx+1) % MAX_COLOR_ANIMATION], (a-(keyIdx*dt)) / dt);\n"
	"\n"
	"	// Final particle position\n"
	"	if(uWorldSpaceSim == 1){\n"
	"		gl_Position = (uProjMat*uModelViewMat) * vec4(inPosition, 1.0);\n"
	"	}\n"
	"	else{\n"
	"		gl_Position = (uProjMat*(uModelViewMat*uModelMat)) * vec4(inPosition, 1.0);\n"
	"	}\n"
	"}\n"
; // </particle_render_vp>

/* Generated from "./shaders\planet.vp" */
static const char* planet_vp = 
	"#version 130\n"
	"\n"
	"in vec4 inPosition;\n"
	"\n"
	"uniform mat4 uModelMat;\n"
	"uniform mat4 uViewMat;\n"
	"uniform mat4 uProjMat;\n"
	"uniform vec3 uCamPos;\n"
	"\n"
	"void main(){\n"
	"	gl_PointSize = (60.0 * 1280/length(uCamPos.xyz-(uModelMat*inPosition).xyz))*0.000001 + 50.0f;\n"
	"\n"
	"	gl_Position = (uProjMat * (uViewMat*uModelMat)) * inPosition;\n"
	"}\n"
	"\n"
; // </planet_vp>

/* Generated from "./shaders\point_light_pass.vp" */
static const char* point_light_pass_vp = 
	"#version 130\n"
	"\n"
	"in vec3 inPosition;\n"
	"\n"
	"uniform mat4 uModelMat;\n"
	"uniform mat4 uViewMat;\n"
	"uniform mat4 uProjMat;\n"
	"\n"
	"void main(){\n"
	"	gl_Position = (uProjMat*(uViewMat*uModelMat)) * vec4(inPosition, 1.0);\n"
	"}\n"
; // </point_light_pass_vp>

/* Generated from "./shaders\rect.vp" */
static const char* rect_vp = 
	"#version 330\n"
	"\n"
	"in vec4 inPosition;\n"
	"in vec2 inTexCoord;\n"
	"\n"
	"out vec2 fsTexCoord;\n"
	"\n"
	"uniform mat4 uMVPMat;\n"
	"\n"
	"void main(){\n"
	"\n"
	"	fsTexCoord = inTexCoord;\n"
	"\n"
	"	gl_Position = uMVPMat*inPosition;\n"
	"}\n"
; // </rect_vp>

/* Generated from "./shaders\skybox.vp" */
static const char* skybox_vp = 
	"#version 130\n"
	"\n"
	"in vec4 inVertex;\n"
	"\n"
	"uniform mat4x4 uModelViewProjection;\n"
	"\n"
	"out vec3 fsTexCoord;\n"
	"\n"
	"void main(){\n"
	"	fsTexCoord = normalize(inVertex.xyz);\n"
	"\n"
	"	gl_Position = uModelViewProjection*inVertex;\n"
	"}\n"
; // </skybox_vp>

/* Generated from "./shaders\skydome.vp" */
static const char* skydome_vp = 
	"#version 330\n"
	"\n"
	"in vec4 inPosition;\n"
	"in vec2 inTexCoord;\n"
	"\n"
	"out vec2 fsTexCoords;\n"
	"out vec3 fsPosition;\n"
	"\n"
	"uniform mat4x4 uModelMat;\n"
	"uniform mat4x4 uViewMat;\n"
	"uniform mat4x4 uProjMat;\n"
	"\n"
	"void main(void) {\n"
	"	mat4x4 modelViewMat = uViewMat* uModelMat;\n"
	"	mat4x4 modelViewProjMat = uProjMat * modelViewMat;\n"
	"\n"
	"	fsTexCoords = inTexCoord.st;\n"
	"\n"
	"	fsPosition = (uModelMat* inPosition).xyz;\n"
	"	\n"
	"    gl_Position = modelViewProjMat * inPosition;\n"
	"}\n"
; // </skydome_vp>

/* Generated from "./shaders\stencil_pass.vp" */
static const char* stencil_pass_vp = 
	"#version 140\n"
	"\n"
	"in vec4 inPosition;\n"
	"\n"
	"uniform mat4 uModelViewProj;\n"
	"\n"
	"void main(){\n"
	"	gl_Position = uModelViewProj * vec4(inPosition.xyz, 1.0);\n"
	"}\n"
; // </stencil_pass_vp>

/* Generated from "./shaders\terrain.vp" */
static const char* terrain_vp = 
	"#version 130\n"
	"\n"
	"#define eNORMAL_PASS 0\n"
	"#define eGODRAY_PASS 1\n"
	"#define eSHADOW_PASS 2\n"
	"\n"
	"in vec4 inPosition;\n"
	"in vec4 inTexture;\n"
	"in vec4 inTiledTexture;\n"
	"in vec3 inNormal;\n"
	"\n"
	"uniform mat4x4 uModelMat;\n"
	"uniform mat4x4 uProjMat;\n"
	"uniform mat4x4 uViewMat;\n"
	"uniform int uPassType;\n"
	"\n"
	"out vec2 fsTexCoords;\n"
	"out vec2 fsTiledTexCoords;\n"
	"out vec3 fsWorldPos;\n"
	"out vec3 fsNormal;\n"
	"\n"
	"void main(){\n"
	"	mat4x4 modelViewMat = uViewMat * uModelMat;\n"
	"	mat4x4 modelViewProjMat = uProjMat * modelViewMat;\n"
	"\n"
	"	if(uPassType == eNORMAL_PASS){\n"
	"		float tileFactor = 1;\n"
	"\n"
	"		fsTexCoords = inTexture.st;\n"
	"		fsTiledTexCoords = inTiledTexture.st*tileFactor;\n"
	"		fsNormal = inNormal;\n"
	"\n"
	"		fsWorldPos = (uModelMat*inPosition).xyz;\n"
	"	}\n"
	"\n"
	"	gl_Position = modelViewProjMat * inPosition;\n"
	"}\n"
; // </terrain_vp>

/* Generated from "./shaders\terrain_deferred.vp" */
static const char* terrain_deferred_vp = 
	"#version 130\n"
	"\n"
	"#define eNORMAL_PASS 0\n"
	"#define eGODRAY_PASS 1\n"
	"#define eSHADOW_PASS 2\n"
	"\n"
	"in vec4 inPosition;\n"
	"in vec4 inTexture;\n"
	"in vec4 inTiledTexture;\n"
	"in vec3 inNormal;\n"
	"\n"
	"uniform mat4x4 uModelMat;\n"
	"uniform mat4x4 uProjMat;\n"
	"uniform mat4x4 uViewMat;\n"
	"uniform int uPassType;\n"
	"\n"
	"out vec2 fsTexCoords;\n"
	"out vec2 fsTiledTexCoords;\n"
	"out vec3 fsWorldPos;\n"
	"out vec3 fsNormal;\n"
	"\n"
	"void main(){\n"
	"	mat4x4 modelViewMat = uViewMat * uModelMat;\n"
	"	mat4x4 modelViewProjMat = uProjMat * modelViewMat;\n"
	"\n"
	"	float tileFactor = 1;\n"
	"\n"
	"	fsTexCoords = inTexture.st;\n"
	"	fsTiledTexCoords = inTiledTexture.st*tileFactor;\n"
	"	fsNormal = inNormal;\n"
	"\n"
	"	fsWorldPos = (uModelMat*inPosition).xyz;\n"
	"\n"
	"	gl_Position = modelViewProjMat * inPosition;\n"
	"}\n"
; // </terrain_deferred_vp>

/* Generated from "./shaders\dir_light_pass.fp" */
static const char* dir_light_pass_fp = 
	"#version 140\n"
	"\n"
	"#pragma include lighting.fp\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"uniform sampler2D uPositionMap;\n"
	"uniform sampler2D uColorMap;\n"
	"uniform sampler2D uNormalMap;\n"
	"uniform vec2 uScreenSize;\n"
	"\n"
	"uniform mat4 uLightViewMat;\n"
	"in mat4 fsLightProjMat;\n"
	"\n"
	"\n"
	"void main(){\n"
	"	//Convert a fragment position to normalized screen space\n"
	"	// so we can use it as a texture coordinate for G-buffer sampling.\n"
	"	vec2 coord = gl_FragCoord.xy / vec2(uScreenSize.x, uScreenSize.y);\n"
	"\n"
	"	// TODO directional light is being calculated for empty pixels (i.e. nothing has been drawn there)\n"
	"	// there has to be a way to avoid this\n"
	"\n"
	"	vec3 worldPos = texture(uPositionMap, coord).xyz;\n"
	"	vec3 color = texture(uColorMap, coord).xyz;\n"
	"	vec3 normal = normalize(texture(uNormalMap, coord).xyz);\n"
	"\n"
	"	\n"
	"	//mat4 DepthBiasMVP = uLightViewMat;\n"
	"	//vec4 ShadowCoord = DepthBiasMVP * vec4(worldPos, 1);\n"
	"	//vec3 projCoords = ShadowCoord.xyz / ShadowCoord.w;\n"
	"//\n"
	"	//float bias = 0.0;\n"
	"	//float visibility = 1;\n"
	"	//if ( texture( uShadowMap, ShadowCoord.xy/ShadowCoord.w ).z  <  (ShadowCoord.z-bias)/ShadowCoord.w){\n"
	"		//visibility = 0.5f;\n"
	"	//}\n"
	"\n"
	"	\n"
	"	vec4 lightColor = calculateDirectionalLight(normal, worldPos);\n"
	"\n"
	"	// TODO move this to a separate shader\n"
	"	//for(int i=0; i<uNumSpotLights; i++){\n"
	"		//lightColor += calculateSpotLight(uSpotLights[i], normal, worldPos);\n"
	"	//}\n"
	"\n"
	"	outFragColor = vec4(color * lightColor.xyz, 1.0);\n"
	"\n"
	"	outFragColor = calcFog(outFragColor, worldPos);\n"
	"}\n"
; // </dir_light_pass_fp>

/* Generated from "./shaders\font.fp" */
static const char* font_fp = 
	"#version 130\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"in vec2 fsTexCoord;\n"
	"\n"
	"uniform sampler2D uTexture;\n"
	"uniform vec4 uColor;\n"
	"\n"
	"void main(){\n"
	"	outFragColor = vec4(1, 1, 1, texture(uTexture, fsTexCoord).a) * vec4(uColor.xyz, 1.0);\n"
	"}\n"
; // </font_fp>

/* Generated from "./shaders\godray.fp" */
static const char* godray_fp = 
	"#version 330\n"
	"\n"
	"in vec2 fsTexCoord;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"// WARNING CHANGED FROM samplerRect to sampler2D for compability reason, probably broken\n"
	"uniform samplerRect uRectImage;\n"
	"uniform vec2 uLightPositionOnScreen;\n"
	"\n"
	"uniform int uNumSamples;\n"
	"uniform float uExposure;\n"
	"uniform float uDecay;\n"
	"uniform float uDensity;\n"
	"uniform float uWeight;\n"
	"\n"
	"//#define NUM_SAMPLES 100\n"
	"//#define EXPOSURE 0.009\n"
	"//#define DECAY 1.0\n"
	"//#define WEIGHT 3.1\n"
	"//#define DENSITY 0.84\n"
	"//#define ILLUMINATION_DECAY 1.0\n"
	"\n"
	"void main(){\n"
	"	// distance from the current texel to screen light position\n"
	"	vec2 deltaTextCoord = vec2( fsTexCoord.st - uLightPositionOnScreen.xy );\n"
	"\n"
	" 	vec2 textCoo = fsTexCoord.st;\n"
	"\n"
	"	// step\n"
	" 	deltaTextCoord *= 1.0 /  float(uNumSamples) * uDensity;\n"
	"\n"
	" 	float illuminationDecay = 1.0;\n"
	"\n"
	" 	for(int i=0; i < uNumSamples ; i++){\n"
	"		// move closer to the light & sample a texel\n"
	"    	textCoo -= deltaTextCoord;\n"
	"\n"
	"    	vec4 sample = texture(uRectImage, textCoo);\n"
	"\n"
	"    	sample *= illuminationDecay * uWeight;\n"
	"    			\n"
	"    	outFragColor += sample;\n"
	"\n"
	"    	illuminationDecay *= uDecay;\n"
	"\n"
	" 	}\n"
	"\n"
	" 	outFragColor *= uExposure;\n"
	"}\n"
; // </godray_fp>

/* Generated from "./shaders\godraysun.fp" */
static const char* godraysun_fp = 
	"#version 130\n"
	"\n"
	"uniform sampler2D uPlanetTexture;\n"
	"uniform vec4 uSourceColor;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"void main(){\n"
	"	outFragColor = texture(uPlanetTexture, gl_PointCoord) * vec4(uSourceColor.rgb, 1);\n"
	"}\n"
	"\n"
; // </godraysun_fp>

/* Generated from "./shaders\lighting.fp" */
static const char* lighting_fp = 
	"#ifndef WT_LIGHTING_FP\n"
	"#define WT_LIGHTING_FP\n"
	"\n"
	"#define MAX_POINT_LIGHTS	( 20 )\n"
	"#define MAX_SPOT_LIGHTS		( 20 )\n"
	"\n"
	"\n"
	"struct DirectionalLight{\n"
	"	vec4 color;\n"
	"	float ambientItensity;\n"
	"	float diffuseItensity;\n"
	"	vec3 direction;\n"
	"}; // </DirectionalLight>\n"
	"\n"
	"struct Attenuation{\n"
	"	float linear;\n"
	"	float constant;\n"
	"	float exponential;\n"
	"}; // </Attenuation>\n"
	"\n"
	"struct PointLight{\n"
	"	vec4 color;\n"
	"	float ambientItensity;\n"
	"	float diffuseItensity;\n"
	"	vec3 position;\n"
	"	Attenuation attenuation;\n"
	"}; // </PointLight>\n"
	"\n"
	"struct SpotLight{\n"
	"	PointLight base;\n"
	"	vec3 direction;\n"
	"	float cutoff;\n"
	"}; // </SpotLight>\n"
	"\n"
	"struct Material{\n"
	"	vec4 ambientColor;\n"
	"	vec4 diffuseColor;\n"
	"	vec4 specularColor;\n"
	"	float shininess;\n"
	"}; // </Material>\n"
	"\n"
	"struct Fog{\n"
	"	float density;\n"
	"	vec4 color;\n"
	"	int enabled;\n"
	"}; // </Fog>\n"
	"\n"
	"struct Lighting{\n"
	"	DirectionalLight directionalLight;\n"
	"	PointLight pointLights[MAX_POINT_LIGHTS];\n"
	"	SpotLight spotLights[MAX_SPOT_LIGHTS];\n"
	"	int numPointLights;\n"
	"	Material material;\n"
	"	Fog fog;\n"
	"	vec3 eyePos;\n"
	"	int numSpotLights;\n"
	"	sampler2D shadowMap;\n"
	"	int shadowMappingEnabled;\n"
	"	float shadowIntensity;\n"
	"}; // </Lighting>\n"
	"\n"
	"// Structs cannot contain variables of sampler types\n"
	"uniform mat4 uLighting_depthBiasLightMVP;\n"
	"uniform Lighting uLighting;\n"
	"\n"
	"vec4 calculateLight(vec3 normal, vec3 worldPos, vec4 color, float ambientIntensity,\n"
	"	float diffuseItensity, vec3 direction, float shadowFactor){\n"
	"	vec4 ambientColor = color * ambientIntensity;\n"
	"	vec4 specularColor = vec4(0, 0, 0, 0);\n"
	"	vec4 diffuseColor = vec4(0, 0, 0, 0);\n"
	"\n"
	"	/*\n"
	"		calculate the cosine of the angle between the light vector and the normal by doing a dot product\n"
	"\n"
	"		The normal passed from the vertex shader is normalized before it is used.\n"
	"		This is because the interpolation the vector went through may have changed its length and it is no longer a unit vector.\n"
	"	*/\n"
	"	float diffuseFactor = dot(normal, -direction);\n"
	"	\n"
	"	if(diffuseFactor > 0){\n"
	"		diffuseColor = color * diffuseItensity * diffuseFactor;\n"
	"\n"
	"		// Drection vertex -> camera\n"
	"		vec3 VertexToEye = normalize(uLighting.eyePos - worldPos);\n"
	"\n"
	"        vec3 LightReflect = normalize(reflect(direction, normal));\n"
	"        float SpecularFactor = dot(VertexToEye, LightReflect);\n"
	"        SpecularFactor = pow(SpecularFactor, uLighting.material.shininess);\n"
	"		\n"
	"        if (SpecularFactor > 0) {\n"
	"            specularColor = color * uLighting.material.specularColor * SpecularFactor;\n"
	"        }\n"
	"	}\n"
	"	else{\n"
	"		/*\n"
	"		If the diffuse factor is negative or equals to zero it means that light strikes the surface at an obtuse angle\n"
	"		in this case the diffuse light has no effect on the surface\n"
	"		*/\n"
	"		diffuseColor = vec4(0, 0, 0, 0);\n"
	"	}\n"
	"\n"
	"	// TODO shouldn't affect ambient\n"
	"	return shadowFactor * ( ambientColor*uLighting.material.ambientColor +  ( diffuseColor*uLighting.material.diffuseColor + specularColor) );\n"
	"}\n"
	"\n"
	"float calculateShadowFactor(vec3 worldPos, vec3 normal){\n"
	"	vec4 shadowCoord = uLighting_depthBiasLightMVP * vec4(worldPos, 1);\n"
	"\n"
	"	float bias = 0.005;\n"
	"	float visibility = 1;\n"
	"	\n"
	"	// TODO do NOT divide by W if doing ortho projection\n"
	"	if ( texture( uLighting.shadowMap, shadowCoord.xy/shadowCoord.w ).z  <  (shadowCoord.z-bias)/shadowCoord.w){\n"
	"		visibility = 1-uLighting.shadowIntensity;\n"
	"	}\n"
	"\n"
	"	return visibility;\n"
	"}\n"
	"\n"
	"vec4 calculateDirectionalLight(vec3 normal, vec3 worldPos){\n"
	"	float shadowFactor = 1.0f;\n"
	"	if(uLighting.shadowMappingEnabled == 1){\n"
	"		shadowFactor = calculateShadowFactor(worldPos, normal);\n"
	"	}\n"
	"\n"
	"	return calculateLight(normal, worldPos, uLighting.directionalLight.color, uLighting.directionalLight.ambientItensity,\n"
	"			uLighting.directionalLight.diffuseItensity, uLighting.directionalLight.direction, shadowFactor);\n"
	"}\n"
	"\n"
	"vec4 calculatePointLight(PointLight light, vec3 normal, vec3 worldPos){\n"
	"	// direction to the point light\n"
	"	vec3 direction = worldPos - light.position;\n"
	"\n"
	"	// distance from the point light\n"
	"	float d = length(direction);\n"
	"\n"
	"	direction = normalize(direction);\n"
	"\n"
	"	float shadowFactor = 1.0f;\n"
	"	if(uLighting.shadowMappingEnabled == 1){\n"
	"		shadowFactor = calculateShadowFactor(worldPos, normal);\n"
	"	}\n"
	"\n"
	"	vec4 color = calculateLight(normal, worldPos, light.color, light.ambientItensity, light.diffuseItensity, direction, shadowFactor);\n"
	"\n"
	"	float att = light.attenuation.constant + light.attenuation.linear * d + light.attenuation.exponential * d * d;\n"
	"\n"
	"	return color / att;\n"
	"\n"
	"}\n"
	"\n"
	"vec4 calculatePointLight(int index, vec3 normal, vec3 worldPos){\n"
	"	return calculatePointLight(uLighting.pointLights[index], normal, worldPos);\n"
	"}\n"
	"\n"
	"vec4 calculateSpotLight(SpotLight light, vec3 normal, vec3 worldPos){\n"
	"	vec3 lightToPixel = normalize(worldPos - light.base.position);\n"
	"\n"
	"    float spotFactor = dot(lightToPixel, light.direction);\n"
	"\n"
	"    if (spotFactor > light.cutoff) {\n"
	"        vec4 color = calculatePointLight(light.base, normal, worldPos);\n"
	"        return color * (1.0 - (1.0 - spotFactor) * 1.0/(1.0 - light.cutoff));\n"
	"    }\n"
	"    else{\n"
	"        return vec4(0,0,0,0);\n"
	"    }\n"
	"}\n"
	"\n"
	"vec4 calcFog(vec4 color, vec3 worldPos){\n"
	"	if(uLighting.fog.enabled == 0){\n"
	"		return color;\n"
	"	}\n"
	"\n"
	"	// distance from the camera eye\n"
	"	float d = abs(distance(worldPos, uLighting.eyePos));\n"
	"\n"
	"	float factor = clamp(\n"
	"		1.0 - exp(-uLighting.fog.density*d), 0.0, 1.0\n"
	"	);\n"
	"\n"
	"	// mix the fragment color with the fog\n"
	"	return mix(color, vec4(uLighting.fog.color.rgb, 1.0), factor);\n"
	"}\n"
	"\n"
	"#endif\n"
; // </lighting_fp>

/* Generated from "./shaders\model.fp" */
static const char* model_fp = 
	"#version 330\n"
	"	\n"
	"#pragma include lighting.fp\n"
	"\n"
	"#define eNORMAL_PASS 0\n"
	"#define eGODRAY_PASS 1\n"
	"#define eSHADOW_PASS 2\n"
	"\n"
	"#define DISABLE(x) (x*0.0000000000000000001)\n"
	"\n"
	"// texture coordinates recieved from the geometry shader\n"
	"in vec2 fsTexCoords;\n"
	"in vec3 fsTangent;\n"
	"in vec3 fsWorldPos;\n"
	"in vec3 fsNormal;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"uniform sampler2D uSampler;\n"
	"uniform sampler2D uNormalMap;\n"
	"uniform int uAlphaTest;\n"
	"uniform vec4 uFogColor;\n"
	"uniform int uPassType;\n"
	"uniform int uUseNormalMap;\n"
	"\n"
	"vec3 bug = vec3(0,0,0);\n"
	"\n"
	"uniform TestBlock{\n"
	"	float r;\n"
	"	float g;\n"
	"	float b;\n"
	"} testBlock;\n"
	"\n"
	"\n"
	"\n"
	"vec3 CalcBumpedNormal(){\n"
	"    vec3 Normal = normalize(fsNormal);\n"
	"    vec3 Tangent = normalize(fsTangent);\n"
	"    Tangent = normalize(Tangent - dot(Tangent, Normal) * Normal);\n"
	"    vec3 Bitangent = cross(Tangent, Normal);\n"
	"    vec3 BumpMapNormal = texture(uNormalMap, fsTexCoords).xyz;\n"
	"    BumpMapNormal = 2.0 * BumpMapNormal - vec3(1.0, 1.0, 1.0);\n"
	"    vec3 NewNormal;\n"
	"    mat3 TBN = mat3(Tangent, Bitangent, Normal);\n"
	"    NewNormal = TBN * BumpMapNormal;\n"
	"    NewNormal = normalize(NewNormal);\n"
	"    return NewNormal;\n"
	"}\n"
	"\n"
	"\n"
	"void main(void){\n"
	"	if(uPassType != eNORMAL_PASS){\n"
	"		// Consider sampling the texture anyway so that we can discard some pixels\n"
	"		// that would otherwise block the godrays\n"
	"		outFragColor = vec4(0, 0, 0, 0);\n"
	"\n"
	"		vec4 texSample = texture(uSampler, fsTexCoords);\n"
	"\n"
	"		// alpha test [always on for now]\n"
	"		//if(texSample.a < 0.5f){\n"
	"			//discard;\n"
	"		//}\n"
	"	}\n"
	"	else{\n"
	"		vec4 texSample = texture(uSampler, fsTexCoords);\n"
	"\n"
	"		//texSample.rgb = (texSample.rgb / texSample.a);\n"
	"		\n"
	"		vec3 normal;\n"
	"\n"
	"		if(uUseNormalMap==1){\n"
	"			normal = CalcBumpedNormal(); \n"
	"		}\n"
	"		else{\n"
	"			normal = normalize(fsNormal);\n"
	"		}\n"
	"\n"
	"		// alpha test [always on for now]\n"
	"		if(texSample.a < 0.5f) {\n"
	"			discard;\n"
	"		}\n"
	"\n"
	"		vec4 lightColor = calculateLight(fsNormal, fsWorldPos, uDirectionalLight.color, uDirectionalLight.ambientItensity,\n"
	"			uDirectionalLight.diffuseItensity, uDirectionalLight.direction);\n"
	"\n"
	"		for(int i=0; i<uNumPointLights; i++){\n"
	"			lightColor += calculatePointLight(uPointLights[i], fsNormal, fsWorldPos);\n"
	"		}\n"
	"			\n"
	"		for(int i=0; i<uNumSpotLights; i++){\n"
	"			lightColor += calculateSpotLight(uSpotLights[i], fsNormal, fsWorldPos);\n"
	"		}\n"
	"\n"
	"#ifdef DEBUG_NORMALS \n"
	"	outFragColor = DISABLE( calcFog(texSample * lightColor) ) + vec4(fsNormal, 0)\n"
	"		+\n"
	"		// TODO normal has to be passed as a p	arameter and not uniform, as it can be altered by the bump map\n"
	"		 DISABLE(vec4(normal, 0));\n"
	"#else\n"
	"\n"
	"		outFragColor = calcFog(texSample * lightColor, fsWorldPos);\n"
	"		\n"
	"		// TODO normal has to be passed as a parameter and not uniform, as it can be altered by the bump map\n"
	"		 \n"
	"#endif\n"
	"\n"
	"		// Lighting calculations were messing with the alpha so this was the temporary solution\n"
	"		outFragColor.a = texSample.a;\n"
	"	}\n"
	"}\n"
; // </model_fp>

/* Generated from "./shaders\model_deferred.fp" */
static const char* model_deferred_fp = 
	"#version 330\n"
	"\n"
	"in vec3 fsWorldPos;\n"
	"in vec3 fsNormal;\n"
	"in vec2 fsTexCoord;\n"
	"in vec3 fsTangent;\n"
	"\n"
	"out vec3 outWorldPos;\n"
	"out vec3 outDiffuse;\n"
	"out vec3 outNormal;\n"
	"out vec4 outGodray;\n"
	"\n"
	"uniform sampler2D uTextureSampler;\n"
	"uniform sampler2D uNormalMap;\n"
	"uniform int uUseNormalMap;\n"
	"uniform int uUseAlphaTest;\n"
	"\n"
	"vec3 calcBumpedNormal(){\n"
	"	// Could probably avoid normalizing these\n"
	"    vec3 normal = normalize(fsNormal);\n"
	"    vec3 tangent = normalize(fsTangent);\n"
	"\n"
	"	// Calculate the bitangent\n"
	"    tangent = normalize(tangent  - dot(tangent, normal) * normal);\n"
	"    vec3 bitangent = cross(tangent, normal);\n"
	"\n"
	"    vec3 bumpMapNormal = texture(uNormalMap, fsTexCoord).xyz;\n"
	"\n"
	"    bumpMapNormal = 2.0 * bumpMapNormal - vec3(1.0, 1.0, 1.0);\n"
	"\n"
	"    mat3 TBN = mat3(tangent, bitangent, normal);\n"
	"\n"
	"    vec3 newNormal = TBN * bumpMapNormal;\n"
	"\n"
	"    return normalize(newNormal );\n"
	"}\n"
	"\n"
	"void main(void) {\n"
	"	outWorldPos = fsWorldPos;\n"
	"\n"
	"	vec4 sample = texture(uTextureSampler, fsTexCoord);\n"
	"	\n"
	"	if(uUseAlphaTest == 1 &&  sample.a < 0.2){\n"
	"		discard;\n"
	"	}\n"
	"\n"
	"	outDiffuse = sample.rgb;\n"
	"\n"
	"	if(uUseNormalMap == 1){\n"
	"		outNormal = calcBumpedNormal();\n"
	"	}\n"
	"	else{\n"
	"		outNormal = normalize(fsNormal);\n"
	"	}\n"
	"	\n"
	"	outGodray = vec4(0, 0, 0, 1);\n"
	"}\n"
; // </model_deferred_fp>

/* Generated from "./shaders\particle.fp" */
static const char* particle_fp = 
	"#version 130\n"
	"\n"
	"uniform sampler2D uParticleTexture;\n"
	"\n"
	"in vec4 fsColor;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"void main(){\n"
	"	outFragColor = texture(uParticleTexture, gl_PointCoord) * fsColor;\n"
	"}\n"
	"\n"
; // </particle_fp>

/* Generated from "./shaders\planet.fp" */
static const char* planet_fp = 
	"#version 130\n"
	"\n"
	"uniform sampler2D uPlanetTexture;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"void main(){\n"
	"	outFragColor = texture(uPlanetTexture, gl_PointCoord);\n"
	"}\n"
	"\n"
; // </planet_fp>

/* Generated from "./shaders\point_light_pass.fp" */
static const char* point_light_pass_fp = 
	"#version 140\n"
	"\n"
	"#pragma include lighting.fp\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"uniform sampler2D uPositionMap;\n"
	"uniform sampler2D uColorMap;\n"
	"uniform sampler2D uNormalMap;\n"
	"uniform vec2 uScreenSize;\n"
	"uniform int uPointLightIndex;\n"
	"\n"
	"uniform mat4 uLightViewMat;\n"
	"in mat4 fsLightProjMat;\n"
	"\n"
	"void main(){\n"
	"	//Convert a fragment position to normalized screen space\n"
	"	// so we can use it as a texture coordinate for G-buffer sampling.\n"
	"	vec2 coord = gl_FragCoord.xy / vec2(uScreenSize.x, uScreenSize.y);\n"
	"\n"
	"	// TODO directional light is being calculated for empty pixels (i.e. nothing has been drawn there)\n"
	"	// there has to be a way to avoid this\n"
	"\n"
	"	vec3 worldPos = texture(uPositionMap, coord).xyz;\n"
	"	vec3 color = texture(uColorMap, coord).xyz;\n"
	"	vec3 normal = normalize(texture(uNormalMap, coord).xyz);\n"
	"\n"
	"	vec4 lightColor = calculatePointLight(uPointLightIndex, normal, worldPos);\n"
	"\n"
	"	outFragColor = vec4(color * lightColor.xyz, 1.0);\n"
	"}\n"
; // </point_light_pass_fp>

/* Generated from "./shaders\rect.fp" */
static const char* rect_fp = 
	"#version 330\n"
	"\n"
	"in vec2 fsTexCoord;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"// WARNING CHANGED FROM samplerRect to sampler2D for compability reason, probably broken\n"
	"uniform samplerRect uRectImage;\n"
	"\n"
	"void main(){\n"
	" 	outFragColor = texture(uRectImage, fsTexCoord);\n"
	"}\n"
; // </rect_fp>

/* Generated from "./shaders\skybox.fp" */
static const char* skybox_fp = 
	"#version 130\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"uniform samplerCube uSkyboxTexture;\n"
	"\n"
	"in vec3 fsTexCoord;\n"
	"\n"
	"void main(){\n"
	"	outFragColor = texture(uSkyboxTexture, fsTexCoord);\n"
	"}\n"
; // </skybox_fp>

/* Generated from "./shaders\skydome.fp" */
static const char* skydome_fp = 
	"#version 330\n"
	"\n"
	"in vec2 fsTexCoords;\n"
	"in vec3 fsPosition;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"uniform sampler2D uSkyTexture;\n"
	"uniform sampler2D uGlowTexture;\n"
	"uniform vec3 uSunPosition;\n"
	"\n"
	"\n"
	"void main(void){\n"
	"	// Normalized fragment position\n"
	"	vec3 fragPos = normalize(fsPosition); \n"
	"\n"
	"	// Normalized sun's position (moving around a normalized sphere)\n"
	"    vec3 sunPos = normalize(uSunPosition );\n"
	"\n"
	"	//This dot product gives a large value near the sun, and a small one far away, and thus models a glow centered at the sun position\n"
	"    float fragDistance = dot(fragPos, sunPos); \n"
	"\n"
	"    // Look up the sky color and glow colors.\n"
	"\n"
	"    vec4 skyColor = texture2D(uSkyTexture, vec2(\n"
	"		(sunPos.y + 1.0) / 2.0, // s - (sun vertical position moved to [0, 1] range from [-1 1]\n"
	"		1-fragPos.y // t - (fragment's distance from the horizon\n"
	"		));\n"
	"\n"
	"    vec4 glowColor = texture2D(uGlowTexture,  vec2(\n"
	"		(sunPos.y + 1.0) / 2.0, // s\n"
	"		1-fragDistance)) // t\n"
	"		 ;\n"
	"\n"
	"    // Combine the color and glow giving the pixel value.\n"
	"\n"
	"    outFragColor = vec4(skyColor.rgb + glowColor.rgb * glowColor.a / 2.0, skyColor.a);\n"
	"}\n"
; // </skydome_fp>

/* Generated from "./shaders\terrain.fp" */
static const char* terrain_fp = 
	"#version 130\n"
	"#extension GL_EXT_gpu_shader4 : enable\n"
	"\n"
	"#pragma include lighting.fp\n"
	"\n"
	"#define eNORMAL_PASS 0\n"
	"#define eGODRAY_PASS 1\n"
	"#define eSHADOW_PASS 2\n"
	"\n"
	"uniform sampler2DArray texArray;\n"
	"uniform sampler2D map;\n"
	"uniform vec4 uFogColor;\n"
	"uniform int uPassType;\n"
	"\n"
	"in vec2 fsTexCoords;\n"
	"in vec2 fsTiledTexCoords;\n"
	"\n"
	"out vec4 outFragColor;\n"
	"\n"
	"void main(){\n"
	"\n"
	"	if(uPassType != eNORMAL_PASS){\n"
	"		outFragColor = vec4(0, 0, 0, 0);\n"
	"	}\n"
	"	else{\n"
	"		// terrain fragment\n"
	"		// Map sample\n"
	"		vec4 mapSample = texture(map, fsTexCoords);\n"
	"		float inverse = 1.0f/(mapSample.r + mapSample.g + mapSample.b);\n"
	"\n"
	"		// Factor in individual textures\n"
	"		outFragColor = vec4(0,0,0,0);\n"
	"		vec4 texSample;\n"
	"		for(int i=0; i<3; i++){\n"
	"			texSample = texture2DArray(texArray, vec3(fsTiledTexCoords*50, i)\n"
	"			);\n"
	"			texSample *= mapSample[i]*inverse;\n"
	"			outFragColor += texSample;\n"
	"		}\n"
	"\n"
	"		vec3 normal = normalize(fsNormal);\n"
	"\n"
	"		// lighting\n"
	"		vec4 lightColor = calculateLight(uDirectionalLight.color, uDirectionalLight.ambientItensity,\n"
	"			uDirectionalLight.diffuseItensity, uDirectionalLight.direction);\n"
	"\n"
	"		for(int i=0; i<uNumPointLights; i++){\n"
	"			lightColor += calculatePointLight(uPointLights[i]);\n"
	"		}\n"
	"\n"
	"		for(int i=0; i<uNumSpotLights; i++){\n"
	"			lightColor += calculateSpotLight(uSpotLights[i]);\n"
	"		}\n"
	"\n"
	"		outFragColor = calcFog(outFragColor * lightColor);\n"
	"	}\n"
	"}\n"
; // </terrain_fp>

/* Generated from "./shaders\terrain_deferred.fp" */
static const char* terrain_deferred_fp = 
	"#version 130\n"
	"#extension GL_EXT_gpu_shader4 : enable\n"
	"\n"
	"#define eNORMAL_PASS 0\n"
	"#define eGODRAY_PASS 1\n"
	"#define eSHADOW_PASS 2\n"
	"\n"
	"uniform sampler2DArray texArray;\n"
	"uniform sampler2D map;\n"
	"uniform vec4 uFogColor;\n"
	"uniform int uPassType;\n"
	"in vec3 fsWorldPos;\n"
	"in vec3 fsNormal;\n"
	"\n"
	"in vec2 fsTexCoords;\n"
	"in vec2 fsTiledTexCoords;\n"
	"\n"
	"out vec3 outWorldPos;\n"
	"out vec3 outDiffuse;\n"
	"out vec3 outNormal;\n"
	"out vec4 outGodray;\n"
	"\n"
	"void main(){\n"
	"\n"
	"	// Map sample\n"
	"	vec4 mapSample = texture(map, fsTexCoords);\n"
	"	float inverse = 1.0f/(mapSample.r + mapSample.g + mapSample.b);\n"
	"\n"
	"	// Factor in individual textures\n"
	"	outDiffuse = vec3(0,0,0);\n"
	"\n"
	"	vec4 texSample;\n"
	"	for(int i=0; i<3; i++){\n"
	"		texSample = texture2DArray(texArray, vec3(fsTiledTexCoords*50, i));\n"
	"		texSample *= mapSample[i]*inverse;\n"
	"		outDiffuse += texSample.xyz;\n"
	"	}\n"
	"\n"
	"	outNormal = normalize(fsNormal);\n"
	"\n"
	"	outGodray = vec4(0, 0, 0, 1);\n"
	"	 \n"
	"	outWorldPos = fsWorldPos;\n"
	"}\n"
; // </terrain_deferred_fp>

/* Generated from "./shaders\noise3D.glsl" */
static const char* noise3D_glsl = 
	"#ifndef NOISE3D_H\n"
	"#define NOISE3D_H\n"
	"//\n"
	"// Description : Array and textureless GLSL 2D/3D/4D simplex \n"
	"//               noise functions.\n"
	"//      Author : Ian McEwan, Ashima Arts.\n"
	"//  Maintainer : ijm\n"
	"//     Lastmod : 20110822 (ijm)\n"
	"//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n"
	"//               Distributed under the MIT License. See LICENSE file.\n"
	"//               https://github.com/ashima/webgl-noise\n"
	"// \n"
	"\n"
	"#extension GL_EXT_gpu_shader4: enable\n"
	"\n"
	"// h [0.0 1.0]\n"
	"vec4 hsv_to_rgb(float h, float s, float v, float a){\n"
	"	float c = v * s;\n"
	"	h = mod((h * 6.0), 6.0);\n"
	"	float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n"
	"	vec4 color;\n"
	"\n"
	"	if (0.0 <= h && h < 1.0) {\n"
	"		color = vec4(c, x, 0.0, a);\n"
	"	} else if (1.0 <= h && h < 2.0) {\n"
	"		color = vec4(x, c, 0.0, a);\n"
	"	} else if (2.0 <= h && h < 3.0) {\n"
	"		color = vec4(0.0, c, x, a);\n"
	"	} else if (3.0 <= h && h < 4.0) {\n"
	"		color = vec4(0.0, x, c, a);\n"
	"	} else if (4.0 <= h && h < 5.0) {\n"
	"		color = vec4(x, 0.0, c, a);\n"
	"	} else if (5.0 <= h && h < 6.0) {\n"
	"		color = vec4(c, 0.0, x, a);\n"
	"	} else {\n"
	"		color = vec4(0.0, 0.0, 0.0, a);\n"
	"	}\n"
	"\n"
	"	color.rgb += v - c;\n"
	"\n"
	"	return color;\n"
	"\n"
	"}\n"
	"\n"
	"\n"
	"vec3 mod289(vec3 x) {\n"
	"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
	"}\n"
	"\n"
	"vec4 mod289(vec4 x) {\n"
	"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
	"}\n"
	"\n"
	"vec4 permute(vec4 x) {\n"
	"     return mod289(((x*34.0)+1.0)*x);\n"
	"}\n"
	"\n"
	"vec4 taylorInvSqrt(vec4 r)\n"
	"{\n"
	"  return 1.79284291400159 - 0.85373472095314 * r;\n"
	"}\n"
	"\n"
	"float snoise(vec3 v)\n"
	"  { \n"
	"  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n"
	"  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n"
	"\n"
	"// First corner\n"
	"  vec3 i  = floor(v + dot(v, C.yyy) );\n"
	"  vec3 x0 =   v - i + dot(i, C.xxx) ;\n"
	"\n"
	"// Other corners\n"
	"  vec3 g = step(x0.yzx, x0.xyz);\n"
	"  vec3 l = 1.0 - g;\n"
	"  vec3 i1 = min( g.xyz, l.zxy );\n"
	"  vec3 i2 = max( g.xyz, l.zxy );\n"
	"\n"
	"  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n"
	"  //   x1 = x0 - i1  + 1.0 * C.xxx;\n"
	"  //   x2 = x0 - i2  + 2.0 * C.xxx;\n"
	"  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n"
	"  vec3 x1 = x0 - i1 + C.xxx;\n"
	"  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n"
	"  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n"
	"\n"
	"// Permutations\n"
	"  i = mod289(i); \n"
	"  vec4 p = permute( permute( permute( \n"
	"             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n"
	"           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n"
	"           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n"
	"\n"
	"// Gradients: 7x7 points over a square, mapped onto an octahedron.\n"
	"// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n"
	"  float n_ = 0.142857142857; // 1.0/7.0\n"
	"  vec3  ns = n_ * D.wyz - D.xzx;\n"
	"\n"
	"  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n"
	"\n"
	"  vec4 x_ = floor(j * ns.z);\n"
	"  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n"
	"\n"
	"  vec4 x = x_ *ns.x + ns.yyyy;\n"
	"  vec4 y = y_ *ns.x + ns.yyyy;\n"
	"  vec4 h = 1.0 - abs(x) - abs(y);\n"
	"\n"
	"  vec4 b0 = vec4( x.xy, y.xy );\n"
	"  vec4 b1 = vec4( x.zw, y.zw );\n"
	"\n"
	"  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n"
	"  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n"
	"  vec4 s0 = floor(b0)*2.0 + 1.0;\n"
	"  vec4 s1 = floor(b1)*2.0 + 1.0;\n"
	"  vec4 sh = -step(h, vec4(0.0));\n"
	"\n"
	"  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n"
	"  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n"
	"\n"
	"  vec3 p0 = vec3(a0.xy,h.x);\n"
	"  vec3 p1 = vec3(a0.zw,h.y);\n"
	"  vec3 p2 = vec3(a1.xy,h.z);\n"
	"  vec3 p3 = vec3(a1.zw,h.w);\n"
	"\n"
	"//Normalise gradients\n"
	"  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n"
	"  p0 *= norm.x;\n"
	"  p1 *= norm.y;\n"
	"  p2 *= norm.z;\n"
	"  p3 *= norm.w;\n"
	"\n"
	"// Mix final noise value\n"
	"  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n"
	"  m = m * m;\n"
	"  return (1 + 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n"
	"                                dot(p2,x2), dot(p3,x3) ) )) / 2;\n"
	"  }\n"
	"\n"
	"  \n"
	"#define RAND_MAX 0x7FFF\n"
	"int seed = 0;\n"
	"\n"
	"int rand1(){\n"
	"    seed = (seed * 125) % 2796203;\n"
	"    return ((seed %  RAND_MAX ) + 1);\n"
	"}\n"
	"\n"
	"int rand_r()\n"
	"{\n"
	"        seed = seed * 1103515245 + 12345;\n"
	"        return (seed % (RAND_MAX + 1));\n"
	"}\n"
	"\n"
	"float rand(){\n"
	"	return float(rand_r())/float( RAND_MAX );\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"int LFSR_Rand_Gen(in int n)\n"
	"{\n"
	"  // <<, ^ and & require GL_EXT_gpu_shader4.\n"
	"  n = (n << 13) ^ n; \n"
	"  return (n * (n*n*15731+789221) + 1376312589) & 0x7fffffff;\n"
	"}\n"
	"\n"
	"float LFSR_Rand_Gen_f( in int n )\n"
	"{\n"
	"  return float(LFSR_Rand_Gen(n));\n"
	"}\n"
	"\n"
	"float noise3f(in vec3 p)\n"
	"{\n"
	"  ivec3 ip = ivec3(floor(p));\n"
	"  vec3 u = fract(p);\n"
	"  u = u*u*(3.0-2.0*u);\n"
	"\n"
	"  int n = ip.x + ip.y*57 + ip.z*113;\n"
	"\n"
	"  float res = mix(mix(mix(LFSR_Rand_Gen_f(n+(0+57*0+113*0)),\n"
	"                          LFSR_Rand_Gen_f(n+(1+57*0+113*0)),u.x),\n"
	"                      mix(LFSR_Rand_Gen_f(n+(0+57*1+113*0)),\n"
	"                          LFSR_Rand_Gen_f(n+(1+57*1+113*0)),u.x),u.y),\n"
	"                 mix(mix(LFSR_Rand_Gen_f(n+(0+57*0+113*1)),\n"
	"                          LFSR_Rand_Gen_f(n+(1+57*0+113*1)),u.x),\n"
	"                      mix(LFSR_Rand_Gen_f(n+(0+57*1+113*1)),\n"
	"                          LFSR_Rand_Gen_f(n+(1+57*1+113*1)),u.x),u.y),u.z);\n"
	"\n"
	"  return 1.0 - res*(1.0/1073741824.0);\n"
	"}\n"
	"\n"
	"float nrand(vec3 seed){\n"
	"	return noise3f( seed );\n"
	"}\n"
	"#endif // </NOISE3D_H>\n"
; // </noise3D_glsl>

const char* getShaderSource(const char* uri){
	if(!gMapInitialized){
		LOGV("Initializing shader map");

		gSourceMap.insert( std::make_pair("font.vp", font_vp) );
		gSourceMap.insert( std::make_pair("godray.vp", godray_vp) );
		gSourceMap.insert( std::make_pair("godraysun.vp", godraysun_vp) );
		gSourceMap.insert( std::make_pair("light_pass.vp", light_pass_vp) );
		gSourceMap.insert( std::make_pair("model.vp", model_vp) );
		gSourceMap.insert( std::make_pair("model_deferred.vp", model_deferred_vp) );
		gSourceMap.insert( std::make_pair("particle.vp", particle_vp) );
		gSourceMap.insert( std::make_pair("particle_gp.vp", particle_gp_vp) );
		gSourceMap.insert( std::make_pair("particle_render.vp", particle_render_vp) );
		gSourceMap.insert( std::make_pair("planet.vp", planet_vp) );
		gSourceMap.insert( std::make_pair("point_light_pass.vp", point_light_pass_vp) );
		gSourceMap.insert( std::make_pair("rect.vp", rect_vp) );
		gSourceMap.insert( std::make_pair("skybox.vp", skybox_vp) );
		gSourceMap.insert( std::make_pair("skydome.vp", skydome_vp) );
		gSourceMap.insert( std::make_pair("stencil_pass.vp", stencil_pass_vp) );
		gSourceMap.insert( std::make_pair("terrain.vp", terrain_vp) );
		gSourceMap.insert( std::make_pair("terrain_deferred.vp", terrain_deferred_vp) );
		gSourceMap.insert( std::make_pair("dir_light_pass.fp", dir_light_pass_fp) );
		gSourceMap.insert( std::make_pair("font.fp", font_fp) );
		gSourceMap.insert( std::make_pair("godray.fp", godray_fp) );
		gSourceMap.insert( std::make_pair("godraysun.fp", godraysun_fp) );
		gSourceMap.insert( std::make_pair("lighting.fp", lighting_fp) );
		gSourceMap.insert( std::make_pair("model.fp", model_fp) );
		gSourceMap.insert( std::make_pair("model_deferred.fp", model_deferred_fp) );
		gSourceMap.insert( std::make_pair("particle.fp", particle_fp) );
		gSourceMap.insert( std::make_pair("planet.fp", planet_fp) );
		gSourceMap.insert( std::make_pair("point_light_pass.fp", point_light_pass_fp) );
		gSourceMap.insert( std::make_pair("rect.fp", rect_fp) );
		gSourceMap.insert( std::make_pair("skybox.fp", skybox_fp) );
		gSourceMap.insert( std::make_pair("skydome.fp", skydome_fp) );
		gSourceMap.insert( std::make_pair("terrain.fp", terrain_fp) );
		gSourceMap.insert( std::make_pair("terrain_deferred.fp", terrain_deferred_fp) );
		gSourceMap.insert( std::make_pair("noise3D.glsl", noise3D_glsl) );

		LOGV("Shader map initialized with 33 shaders");

		gMapInitialized = true;
	}

	SourceMap::iterator res = gSourceMap.find(uri);

	return res == gSourceMap.end() ? NULL : res->second;
}

} // </wt>
